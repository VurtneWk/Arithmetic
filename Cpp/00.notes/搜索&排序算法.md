## 搜索

### 二分搜索

代码实现和复杂度分析

#### 非递归实现

```cpp
// 二分搜索非递归实现
int binarySearch(int arr[], int size, int val) {
    int first = 0;
    int last = size - 1;
    // * 注意条件判断
    while (first <= last) {
        int middle = (first + last) / 2;
        if (arr[middle] == val) {
            return middle;
        } else if (arr[middle] > val) {  // 值在左边
            last = middle - 1;
        } else {
            first = middle + 1;
        }
    }
    return -1;
}

int main() {
    int arr[] = {12, 25, 34, 39, 45, 57, 63, 78, 82, 96, 100};
    int size = sizeof arr / sizeof arr[0];
    cout << binarySearch(arr, size, 39) << endl;//3
    cout << binarySearch(arr, size, 45) << endl;//4
    cout << binarySearch(arr, size, 96) << endl;//9
    cout << binarySearch(arr, size, 64) << endl;//-1
}
```

**时间复杂度**： $O(log_2 N)$

![image-20250313144458151](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131445869.png) 

> [!IMPORTANT] 
>
> **BST树**：**Binary Search Tree**（**二叉搜索树**）
>
> 层数L，总个数N，则 
>
> 每一层的节点数： $2^{L-1}$ ，
>
> 总节点数 $n = 2^L - 1$
>
> 去掉1，$n = 2^L$ 得出 $L = log_2 N$

#### 递归实现

```cpp
/**
 * 在 arr 数组的 [start,end] 索引范围内查找值val
 * @param arr[] 数组
 * @param start 开始索引
 * @param end 结束索引
 * @param val 要查找的值
 *
 * * 这个函数必须在前面先声明/定义 ， 才能在下面的方法中使用
 */
int binarySearch(int arr[], int start, int end, int val) {
    // 递归结束条件
    if (start > end) {
        return -1;
    }
    int mid = (start + end) / 2;
    if (arr[mid] == val) {
        return mid;
    } else if (arr[mid] > val) {
        return binarySearch(arr, start, mid - 1, val);
    } else {
        return binarySearch(arr, mid + 1, end, val);
    }
}

// 二分搜索递归代码
int binarySearch(int arr[], int size, int val) { return binarySearch(arr, 0, size - 1, val); }

// 测试 二分搜索
int main() {
    int arr[] = {12, 25, 34, 39, 45, 57, 63, 78, 82, 96, 100};
    int size = sizeof arr / sizeof arr[0];
    cout << binarySearch(arr, size, 39) << endl;
    cout << binarySearch(arr, size, 45) << endl;
    cout << binarySearch(arr, size, 96) << endl;
    cout << binarySearch(arr, size, 64) << endl;
}
```

> [!important]
>
> 1、一定要搞清楚递归函数的意义是什么返回值、参数列表，他能完成什么功能。
>
> 2、一定有递归结束的条件！！
>
> 3、每个数据规模要写好他们之间的计算关系
>
> 
>
> 递归问题的思考是水平方向上的！
>
> 递归代码的具体执行是垂直方向上的！

## 排序算法

关注算法的**时间复杂度（平均，最优，最差）**和**空间复杂度**和**稳定性**。

### 冒泡排序

**特点**：相邻元素两两比较，把值大的元素往下交换。

**缺点**：数据交换的次数太多了。

![image-20250313162826041](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131628101.png) 

#### 时间复杂度

| 情况                     | 过程                 | 比较次数                   | 交换次数                   | 时间复杂度 |
| ------------------------ | -------------------- | -------------------------- | -------------------------- | ---------- |
| **最优情况**（已排序）   | 不发生交换，直接退出 | $n-1$ 次                   | 0 次                       | $O(n)$     |
| **最差情况**（完全逆序） | 每次都交换           | $\frac{n(n-1)}{2}$ 次      | $\frac{n(n-1)}{2}$ 次      | $O(n^2)$   |
| **平均情况**             | 需要部分交换         | 大约 $\frac{n(n-1)}{4}$ 次 | 大约 $\frac{n(n-1)}{4}$ 次 | $O(n^2)$   |

> [!NOTE]
>
> 为什么 $\frac{n(n-1)}{2}$ 次 ？
>
> ```cpp
> for (int i = 0; i < n; i++) {  
>     for (int j = i + 1; j < n; j++) {  
>         // 这里执行的操作次数是多少？
>     }  
> }
> ```
>
> - 当 i = 0，j 从 1 到 n-1，共执行 n-1 次。
>
> - 当 i = 1，j 从 2 到 n-1，共执行 n-2 次。
>
> - 当 i = 2，j 从 3 到 n-1，共执行 n-3 次。
>
> - …
>
> - 当 i = n-2，j = n-1，执行 1 次。
>
> - 当 i = n-1，j 从 n 开始，不执行，次数为 0。
>
> 总执行次数就是：(n-1) + (n-2) + (n-3) + … + 3 + 2 + 1 + 0
>
> 等差数列： $S = \frac{(n-1) \times (n)}{2}$   => （首项+末项） 项数 / 2

#### 代码实现

```cpp
void bubbleSort(int arr[], int size) {
    // 趟数   最后一趟只剩下 1个元素，所以 size - 1
    for (int i = 0; i < size - 1; i++) {
        bool swapped = false;  // 用于优化，防止已排序的数组继续遍历
        // 每一趟的处理 每趟要比上一趟少处理一个数
        for (int j = 0; j < size - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
                swapped = true;
            }
        }
        if (!swapped) {
            break;
        }
    }
}
```

### 选择排序

**特点**：每次在剩下的元素中选择值最小的元素，和当前元素进行交换。

**缺点**：相比于冒泡排序，交换的次数少了，但是比较的次数依然很多。

![image-20250313174550822](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131745918.png) 

#### 代码实现

```cpp
void choiceSort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        // 记录最小值索引
        int index = i;
        // 每次是从记录的元素的下一个开始
        for (int j = i + 1; j < size; j++) {
            if (arr[j] < arr[index]) {
                index = j;
            }
        }
        // 如果找到和一开始记录的最小值不一样，则进行交换
        if (index != i) {
            int tmp = arr[i];
            arr[i] = arr[index];
            arr[index] = tmp;
        }
    }
}
```

### 插入排序

**特点**：从第二个元素开始，把前面的元素序列当作已经有序的，然后找合适的位置插入。

**优点**：插入排序是普通排序里面效率最高的排序算法，而且在数据越趋于有序的情况下，插入排序的效率是最高的。

![image-20250313175024643](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131750733.png) 

#### 代码实现

```cpp
void insertSort(int arr[], int size) {
    // 从第一个开始
    for (int i = 1; i < size; i++) {
        int val = arr[i];  // 要比较的值
        int j = i - 1;
        // 和前面的进行比较
        while (j >= 0 && arr[j] > val) {
            arr[j + 1] = arr[j];  // 如果前面的值大于当前值，后移
            j--;
        }
        arr[j + 1] = val;  // 找到位置后插入
    }
}
```

#### 时间复杂度： 

最好 $O(n)$ , 最差 $O(n^2)$ 

### 希尔排序

**特点**：可以看作是多路的插入排序，分组的数据越趋于有序，整体上的数据也越趋于有序，插入排序效率完美体现。

> 查看插入排序的图

对数据进行分组后进行插入排序，让数据趋于有序，最后的插入排序就会变高。

#### 代码实现

```cpp
void shellSort(int arr[], int size) {
    for (int gap = size / 2; gap > 0; gap = gap / 2) {
        // 从第一个开始
        for (int i = gap; i < size; i++) {
            int val = arr[i];  // 要比较的值
            int j = i - gap;
            // 和前面的进行比较
            while (j >= 0 && arr[j] > val) {
                arr[j + gap] = arr[j];  // 如果前面的值大于当前值，后移
                j -= gap;
            }
            arr[j + gap] = val;  // 找到位置后插入
        }
    }
}
```

## 排序性能对比

| 排序算法 | 平均时间复杂度                               | 最好时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | -------------------------------------------- | -------------- | -------------- | ---------- | ------ |
| 冒泡排序 | $O(n^2)$                                     | $O(n)$         | $O(n^2)$       | $O(1)$     | 稳定   |
| 选择排序 | $O(n^2)$                                     | $O(n^2)$       | $O(n^2)$       | $O(1)$     | 不稳定 |
| 插入排序 | $O(n^2)$                                     | $O(n)$         | $O(n^2)$       | $O(1)$     | 稳定   |
| 希尔排序 | 依赖增量序列（$O(n^{1.3}) \sim O(n^{1.5})$） | $O(n)$         | $O(n^2)$       | $O(1)$     | 不稳定 |



| 排序算法             | 100000 组（单位：ms） |
| -------------------- | --------------------- |
| 冒泡排序（效率最低） | 14.0386s              |
| 选择排序（效率次之） | 5.04798s              |
| 插入排序（效率最高） | 2.76331s              |
| 希尔排序（效率更高） | 0.016159s             |

插入排序的效率最好，尤其是在数据已经趋于有序的情况下，采用**插入排序效率最高**。

一般中等数据量的排序都用希尔排序，选择合适的增量序列，效率就已经不错了，如果数据量比较大，可以选择高级的排序算法，如**快速排序**。