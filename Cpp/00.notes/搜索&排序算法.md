## 搜索

### 二分搜索

代码实现和复杂度分析

#### 非递归实现

```cpp
// 二分搜索非递归实现
int binarySearch(int arr[], int size, int val) {
    int first = 0;
    int last = size - 1;
    // * 注意条件判断
    while (first <= last) {
        int middle = (first + last) / 2;
        if (arr[middle] == val) {
            return middle;
        } else if (arr[middle] > val) {  // 值在左边
            last = middle - 1;
        } else {
            first = middle + 1;
        }
    }
    return -1;
}

int main() {
    int arr[] = {12, 25, 34, 39, 45, 57, 63, 78, 82, 96, 100};
    int size = sizeof arr / sizeof arr[0];
    cout << binarySearch(arr, size, 39) << endl;//3
    cout << binarySearch(arr, size, 45) << endl;//4
    cout << binarySearch(arr, size, 96) << endl;//9
    cout << binarySearch(arr, size, 64) << endl;//-1
}
```

**时间复杂度**： $O(log_2 N)$

![image-20250313144458151](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131445869.png) 

> [!IMPORTANT] 
>
> **BST树**：**Binary Search Tree**（**二叉搜索树**）
>
> 层数L，总个数N，则 
>
> 每一层的节点数： $2^{L-1}$ ，
>
> 总节点数 $n = 2^L - 1$
>
> 去掉1，$n = 2^L$ 得出 $L = log_2 N$

#### 递归实现

```cpp
/**
 * 在 arr 数组的 [start,end] 索引范围内查找值val
 * @param arr[] 数组
 * @param start 开始索引
 * @param end 结束索引
 * @param val 要查找的值
 *
 * * 这个函数必须在前面先声明/定义 ， 才能在下面的方法中使用
 */
int binarySearch(int arr[], int start, int end, int val) {
    // 递归结束条件
    if (start > end) {
        return -1;
    }
    int mid = (start + end) / 2;
    if (arr[mid] == val) {
        return mid;
    } else if (arr[mid] > val) {
        return binarySearch(arr, start, mid - 1, val);
    } else {
        return binarySearch(arr, mid + 1, end, val);
    }
}

// 二分搜索递归代码
int binarySearch(int arr[], int size, int val) { return binarySearch(arr, 0, size - 1, val); }

// 测试 二分搜索
int main() {
    int arr[] = {12, 25, 34, 39, 45, 57, 63, 78, 82, 96, 100};
    int size = sizeof arr / sizeof arr[0];
    cout << binarySearch(arr, size, 39) << endl;
    cout << binarySearch(arr, size, 45) << endl;
    cout << binarySearch(arr, size, 96) << endl;
    cout << binarySearch(arr, size, 64) << endl;
}
```

> [!important]
>
> 1、一定要搞清楚递归函数的意义是什么返回值、参数列表，他能完成什么功能。
>
> 2、一定有递归结束的条件！！
>
> 3、每个数据规模要写好他们之间的计算关系
>
> 
>
> 递归问题的思考是水平方向上的！
>
> 递归代码的具体执行是垂直方向上的！

## 排序算法

关注算法的**时间复杂度（平均，最优，最差）**和**空间复杂度**和**稳定性**。

### 冒泡排序

**特点**：相邻元素两两比较，把值大的元素往下交换。

**缺点**：数据交换的次数太多了。

![image-20250313162826041](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131628101.png) 

##### 时间复杂度

| 情况                     | 过程                 | 比较次数                   | 交换次数                   | 时间复杂度 |
| ------------------------ | -------------------- | -------------------------- | -------------------------- | ---------- |
| **最优情况**（已排序）   | 不发生交换，直接退出 | $n-1$ 次                   | 0 次                       | $O(n)$     |
| **最差情况**（完全逆序） | 每次都交换           | $\frac{n(n-1)}{2}$ 次      | $\frac{n(n-1)}{2}$ 次      | $O(n^2)$   |
| **平均情况**             | 需要部分交换         | 大约 $\frac{n(n-1)}{4}$ 次 | 大约 $\frac{n(n-1)}{4}$ 次 | $O(n^2)$   |

> [!NOTE]
>
> 为什么 $\frac{n(n-1)}{2}$ 次 ？
>
> ```cpp
> for (int i = 0; i < n; i++) {  
>     for (int j = i + 1; j < n; j++) {  
>         // 这里执行的操作次数是多少？
>     }  
> }
> ```
>
> - 当 i = 0，j 从 1 到 n-1，共执行 n-1 次。
>
> - 当 i = 1，j 从 2 到 n-1，共执行 n-2 次。
>
> - 当 i = 2，j 从 3 到 n-1，共执行 n-3 次。
>
> - …
>
> - 当 i = n-2，j = n-1，执行 1 次。
>
> - 当 i = n-1，j 从 n 开始，不执行，次数为 0。
>
> 总执行次数就是：(n-1) + (n-2) + (n-3) + … + 3 + 2 + 1 + 0
>
> 等差数列： $S = \frac{(n-1) \times (n)}{2}$   => （首项+末项） 项数 / 2

### 选择排序

特点：每次在剩下的元素中选择值最小的元素，和当前元素进行交换。

缺点：相比于冒泡排序，交换的次数少了，但是比较的次数依然很多。

### 插入排序

特点：从第二个元素开始，把前面的元素序列当作已经有序的，然后找合适的位置插入。

优点：插入排序是普通排序里面效率最高的排序算法，而且在数据越趋于有序的情况下，插入排序的效率是最高的。

### 希尔排序

特点：可以看作是多路的插入排序，分组的数据越趋于有序，整体上的数据也越趋于有序，插入排序效率完美体现。

