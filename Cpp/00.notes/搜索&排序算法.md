## 搜索

### 二分搜索

代码实现和复杂度分析

#### 非递归实现

```cpp
// 二分搜索非递归实现
int binarySearch(int arr[], int size, int val) {
    int first = 0;
    int last = size - 1;
    // * 注意条件判断
    while (first <= last) {
        int middle = (first + last) / 2;
        if (arr[middle] == val) {
            return middle;
        } else if (arr[middle] > val) {  // 值在左边
            last = middle - 1;
        } else {
            first = middle + 1;
        }
    }
    return -1;
}

int main() {
    int arr[] = {12, 25, 34, 39, 45, 57, 63, 78, 82, 96, 100};
    int size = sizeof arr / sizeof arr[0];
    cout << binarySearch(arr, size, 39) << endl;//3
    cout << binarySearch(arr, size, 45) << endl;//4
    cout << binarySearch(arr, size, 96) << endl;//9
    cout << binarySearch(arr, size, 64) << endl;//-1
}
```

**时间复杂度**： $O(log_2 N)$

![image-20250313144458151](https://gitee.com/vurtnewk/typora-image/raw/master/images03/202503131445869.png) 

> [!IMPORTANT] 
>
> **BST树**：**Binary Search Tree**（**二叉搜索树**）
>
> 层数L，总个数N，则 
>
> 每一层的节点数： $2^{L-1}$ ，
>
> 总节点数 $n = 2^L - 1$
>
> 去掉1，$n = 2^L$ 得出 $L = log_2 N$

#### 递归实现

