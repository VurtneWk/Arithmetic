# 二叉树

## 1. 相关术语

### **① 节点（Node）**

二叉树的基本单位，每个节点包含：

- **值（Value）**：存储的数据。
- **左孩子（Left Child）**：指向左子树的指针。
- **右孩子（Right Child）**：指向右子树的指针。
- **双亲节点（Parent Node）**：当前节点的上一级节点（如果存在）。
- **子节点（Child Node）**：某个节点的直接后代，包括左孩子和右孩子。

### **② 根节点（Root Node）**

二叉树的最顶层节点，**没有父节点**。

### **③ 叶子节点（Leaf Node）**

没有任何子节点的节点，即 **左孩子和右孩子都为空**。

### **④ 内部节点（Internal Node）**

至少有一个子节点的节点（非叶子节点）。

### **⑤ 子树（Subtree）**

以某个节点为根的所有子节点构成的树。

### **⑥ 深度（Depth）**

某个节点到 **根节点的路径长度**（从 0 开始）。

### **⑦ 高度（Height）**

某个节点到 **最远叶子节点的路径长度**（从 0 开始）。

### **⑧ 层（Level）**

从 **根节点开始**，按照层次编号：

- 根节点在 **第 1 层**（Level 1）。
- 直接连接根节点的子节点在 **第 2 层**，依此类推。

------

## 2. 二叉树的示例

```
        A  ← 根节点
       / \
      B   C
     / \   \
    D   E   F
```

- **A 是根节点**
- **B 和 C 是 A 的子节点**
- **A 是 B 和 C 的双亲（父）节点**
- **D 和 E 是 B 的子节点**
- **F 是 C 的子节点**
- **D、E、F 是叶子节点**

------

## 3. 特殊的二叉树

### **① 满二叉树（Full Binary Tree）**

- 每个节点 **要么有 0 个子节点（叶子节点），要么有 2 个子节点**。
- **所有叶子节点的深度相同**。

示例：

```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

所有节点都有 0 或 2 个子节点，所以是**满二叉树**。

------

### **② 完全二叉树（Complete Binary Tree）**

- **必须是从左往右填充**的。
- **最后一层的节点可以不满，但必须靠左对齐**。

示例：

```
        1
       / \
      2   3
     / \  /
    4   5 6
```

- **是完全二叉树** ✅（最底层的 6 处于左侧）
- **但不是满二叉树** ❌（因为 3 只有一个子节点）

------

### **③ 平衡二叉树（Balanced Binary Tree）**

- **任何节点的左右子树高度差 ≤ 1**。

------

### **④ 二叉搜索树（BST, Binary Search Tree）**

- **左子树的值 < 根节点的值 < 右子树的值**。

示例：

```
       10
      /  \
     5    15
    / \   /  \
   3   7 12  18
```

- **左子树**：所有值 < 10
- **右子树**：所有值 > 10

## 规律

层数L 和 元素个数 n 的关系 (每层都满的情况)

$n = 2^0 + 2^1 + 2^2 + ... + 2^{L-1}$

等比数列求和公式为：

$S = a_1 \cdot \frac{r^n - 1}{r - 1}$

其中：
- $a_1$ 是首项（这里 $a_1 = 2^0 = 1$），
- $r$ 是公比（这里 $r = 2$），
- $n$ 是项数（这里 $n = L$）。

代入公式：

$n = 1 \cdot \frac{2^L - 1}{2 - 1} = 2^L - 1$

$L = log_2n$ （省略了个+1）

# BST二叉搜索树

**BST** 树 称作**二叉搜索树**（Binary Search Tree）或者**二叉排序树**（Binary Sort Tree），它或者是一颗空树；或者是具有下列性质的二叉树：

## 核心特性

- **有序结构**：对于每个节点，左子树的所有节点值均小于该节点，右子树的所有节点值均大于该节点。
- **操作效率**：在平衡状态下，查找、插入、删除的时间复杂度为 $O(log⁡n)$；若树退化为链表（如插入有序数据），时间复杂度退化为 $O(n)$。

## 术语

在二叉搜索树（BST）中，**前驱节点**和**后继节点**是与某个节点相关的两个重要概念，分别表示该节点在**中序遍历序列**中的前一个节点和后一个节点。以下是详细解释和 **C++** 实现：

---

### **1. 中序遍历（Inorder Traversal）**
中序遍历是 BST 的核心遍历方式，其顺序为：
1. 遍历左子树
2. 访问当前节点
3. 遍历右子树

中序遍历的结果是一个**升序排列**的节点值序列。例如，对于以下 BST：
```
    4
   / \
  2   6
 / \ / \
1  3 5  7
```
中序遍历结果为：`[1, 2, 3, 4, 5, 6, 7]`。

---

### **2. 前驱节点（Predecessor）**
#### **定义**
- 前驱节点是当前节点在中序遍历序列中的**前一个节点**。
- 如果当前节点是序列中的第一个节点，则其前驱节点为 `null`。

#### **查找方法**
1. **如果当前节点有左子树**：
   - 前驱节点是左子树中的**最大值**（即左子树的最右节点）。
   - 例如，节点 `4` 的前驱节点是 `3`（左子树 `[2, 1, 3]` 的最大值）。
2. **如果当前节点没有左子树**：
   - 前驱节点是当前节点的**最近祖先节点**，且当前节点位于该祖先节点的右子树中。
   - 例如，节点 `1` 的前驱节点是 `null`，节点 `3` 的前驱节点是 `2`。

---

### **3. 后继节点（Successor）**
#### **定义**
- 后继节点是当前节点在中序遍历序列中的**后一个节点**。
- 如果当前节点是序列中的最后一个节点，则其后继节点为 `null`。

#### **查找方法**
1. **如果当前节点有右子树**：
   - 后继节点是右子树中的**最小值**（即右子树的最左节点）。
   - 例如，节点 `4` 的后继节点是 `5`（右子树 `[6, 5, 7]` 的最小值）。
2. **如果当前节点没有右子树**：
   - 后继节点是当前节点的**最近祖先节点**，且当前节点位于该祖先节点的左子树中。
   - 例如，节点 `7` 的后继节点是 `null`，节点 `5` 的后继节点是 `6`。

---

### **4. C++ 实现**

#### **定义树节点**
```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

#### **查找前驱节点**
```cpp
TreeNode* findPredecessor(TreeNode* root, TreeNode* node) {
    if (node->left) {
        // 前驱节点是左子树的最大值
        TreeNode* current = node->left;
        while (current->right) {
            current = current->right;
        }
        return current;
    } else {
        // 前驱节点是最近的祖先节点，且当前节点在其右子树中
        TreeNode* predecessor = nullptr;
        TreeNode* current = root;
        while (current) {
            if (node->val > current->val) {
                predecessor = current;
                current = current->right;
            } else if (node->val < current->val) {
                current = current->left;
            } else {
                break;
            }
        }
        return predecessor;
    }
}
```

#### **查找后继节点**
```cpp
TreeNode* findSuccessor(TreeNode* root, TreeNode* node) {
    if (node->right) {
        // 后继节点是右子树的最小值
        TreeNode* current = node->right;
        while (current->left) {
            current = current->left;
        }
        return current;
    } else {
        // 后继节点是最近的祖先节点，且当前节点在其左子树中
        TreeNode* successor = nullptr;
        TreeNode* current = root;
        while (current) {
            if (node->val < current->val) {
                successor = current;
                current = current->left;
            } else if (node->val > current->val) {
                current = current->right;
            } else {
                break;
            }
        }
        return successor;
    }
}
```

---

### **5. 示例**
以下 BST：
```
    4
   / \
  2   6
 / \ / \
1  3 5  7
```
- 节点 `4` 的前驱节点是 `3`，后继节点是 `5`。
- 节点 `2` 的前驱节点是 `1`，后继节点是 `3`。
- 节点 `7` 的前驱节点是 `6`，后继节点是 `null`。

---

### **6. 应用场景**
- **删除节点**：在删除 BST 中的节点时，如果待删除节点有两个子节点，通常用其前驱或后继节点替换。
- **范围查询**：查找某个范围内的所有节点时，可以利用前驱和后继节点快速定位。

---

### **总结**
- **前驱节点**：中序遍历序列中当前节点的前一个节点。
- **后继节点**：中序遍历序列中当前节点的后一个节点。
- 查找方法依赖于 BST 的有序性质，通过左子树的最大值或右子树的最小值快速定位。